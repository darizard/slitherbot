<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Alerts for Dari</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <link rel="icon" href="/slitherbot/public/favicon.ico" />
  <link rel="stylesheet" href="/slitherbot/public/css/base-style.css" />
  <link rel="stylesheet" href="/slitherbot/public/css/alerts.css" />
</head>
<body>
  <audio id="alert-audio">
	<source src="" type="audio/mpeg">
	Your browser does not support the audio element.
  </audio>
  <img id="alert-image" src="" />
</body>

<script>
let socket
connectWebSocket()

  function connectWebSocket() {

    // if a socket was previously defined, clean up its listeners and close it
    if(socket) {
      socket.onopen = null
      socket.onmessage = null
      socket.onclose = null
      socket.onerror = null
      socket.close()
    }

    // TODO: Implement changes to the way the WebSocket connects to allow authentication for different users
    socket = new WebSocket('wss://dari.monster/twitch?clientType=alerts')

    let pingIntervalID = setInterval(() => {

      if(socket.readyState === WebSocket.OPEN) socket.send(JSON.stringify({type: "ping"}))

    }, 60000) // Ping the WS server every 1 minute to keep the connection alive

    let reconnectIntervalID = setInterval(() => {

      if(socket.readyState !== WebSocket.OPEN && socket.readyState !== WebSocket.CONNECTING) {
        console.log('Reconnecting WebSocket for alerts.ejs')
        clearInterval(pingIntervalID)
        clearInterval(reconnectIntervalID)
        connectWebSocket()
      }

    }, 15000) // Check for non-open and non-connecting socket every 15 seconds
  
    socket.addEventListener('open', () => {
      console.log('WebSocket connection established for alerts.ejs')
    })

    socket.addEventListener('close', () => {
      console.log('WebSocket connection closed for alerts.ejs')
    })

    socket.addEventListener('message', event => {

      let eventData
      try { eventData = JSON.parse(event.data) } 
      catch (e) { return } // If non-json received over WebSocket, ignore it.

      // TODO: Allow different alerts to queue up one after the other instead of just replacing the current alert. 
      // This will likely require changes to the way the WebSocket server sends messages to include some sort of queue ID or timestamp, 
      // and changes to the client to manage a queue of incoming alerts and display them one at a time for their specified duration.
      if(eventData.type === "alert") {

        console.log('Message received from server: ', eventData)
        console.log('MessageEvent object: ', event)
        const alertImageElement = document.getElementById('alert-image')
        const alertAudioElement = document.getElementById('alert-audio')

        if(eventData.imageFile) {

          alertImageElement.src = "/slitherbot/public/images/" + eventData.imageFile || ''

        }

        if(eventData.audioFile) {

          alertAudioElement.src = "/slitherbot/public/sounds/" + eventData.audioFile || ''
          alertAudioElement.play()

        }
        
        setTimeout(() => {
          alertImageElement.src = alertAudioElement.src = ''
        }, eventData.duration || 8000) // Reset to default image after 8 seconds

      }

    }) // End of 'message' event listener

  }
</script>

</html>